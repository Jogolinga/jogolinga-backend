// ===================================================================
// server.js - SERVEUR PRINCIPAL JOGOLINGA BACKEND
// ===================================================================
require('dotenv').config();

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const morgan = require('morgan');
const { body, validationResult } = require('express-validator');

const app = express();
const PORT = process.env.PORT || 3001;

// V√©rification des variables d'environnement critiques
const requiredEnvVars = [
  'JWT_SECRET',
  'SUPABASE_URL',
  'SUPABASE_SERVICE_KEY',
  'GOOGLE_CLIENT_ID'
];

requiredEnvVars.forEach(varName => {
  if (!process.env[varName]) {
    console.error(`‚ùå Variable d'environnement manquante: ${varName}`);
    process.exit(1);
  }
});

console.log('‚úÖ Variables d\'environnement v√©rifi√©es');

// Services
const authService = require('./services/authService');
const subscriptionService = require('./services/subscriptionService');
const audioService = require('./services/audioService');

// ===================================================================
// MIDDLEWARE DE S√âCURIT√â
// ===================================================================

// Protection g√©n√©rale
app.use(helmet({
  crossOriginEmbedderPolicy: false,
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      scriptSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      connectSrc: ["'self'", "https://api.stripe.com", "https://*.supabase.co"]
    }
  }
}));

// CORS s√©curis√© - VERSION CORRIG√âE
const allowedOrigins = [
  'http://localhost:3000',
  'http://localhost:3001',
  'https://localhost:3000',
  'https://jogolinga-frontend.vercel.app',
  process.env.FRONTEND_URL,
  process.env.CORS_ORIGIN
].filter(Boolean);

console.log('üîß CORS - Origines autoris√©es:', allowedOrigins);

app.use(cors({
  origin: function (origin, callback) {
    // Permettre les requ√™tes sans origin (mobile apps, postman, etc.)
    if (!origin) {
      console.log('üîì CORS: Requ√™te sans origin (autoris√©e)');
      return callback(null, true);
    }
    
    console.log('üîç CORS: Origin re√ßue:', origin);
    
    if (allowedOrigins.includes(origin)) {
      console.log('‚úÖ CORS: Origin accept√©e:', origin);
      callback(null, true);
    } else {
      console.warn(`‚ùå CORS: Origine rejet√©e: ${origin}`);
      console.log('üìã CORS: Origines autoris√©es:', allowedOrigins);
      callback(new Error('Non autoris√© par CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  optionsSuccessStatus: 200
}));

// Middleware pour les preflight requests
app.options('*', (req, res) => {
  console.log('üîÑ CORS: Preflight request pour:', req.path);
  res.sendStatus(200);
});

// Rate limiting global
const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100,
  message: { error: 'Trop de requ√™tes, r√©essayez dans 15 minutes' },
  standardHeaders: true,
  legacyHeaders: false
});

// Rate limiting strict pour authentification
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 10, // Augment√© de 5 √† 10 pour les tests
  message: { error: 'Trop de tentatives de connexion, r√©essayez dans 15 minutes' }
});

app.use('/api/', globalLimiter);
app.use('/api/auth/', authLimiter);

// Middleware g√©n√©ral
app.use(morgan('combined'));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// ===================================================================
// ROUTES DE SANT√â
// ===================================================================

// Health check basique
app.get('/api/health', (req, res) => {
  console.log('ü©∫ Health check demand√©');
  res.json({
    status: 'OK',
    message: 'JogoLinga Backend is running',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    uptime: Math.floor(process.uptime()),
    version: '1.0.0'
  });
});

// Status d√©taill√© (pour monitoring)
app.get('/api/status', async (req, res) => {
  try {
    console.log('üìä Status d√©taill√© demand√©');
    const status = {
      server: 'healthy',
      database: await subscriptionService.checkDatabaseHealth(),
      supabase: !!process.env.SUPABASE_URL,
      stripe: !!process.env.STRIPE_SECRET_KEY,
      google: !!process.env.GOOGLE_CLIENT_ID,
      cors: allowedOrigins,
      timestamp: new Date().toISOString(),
      uptime: Math.floor(process.uptime())
    };
    
    res.json(status);
  } catch (error) {
    console.error('‚ùå Erreur status:', error);
    res.status(500).json({ 
      error: 'Erreur de status',
      timestamp: new Date().toISOString()
    });
  }
});

// ===================================================================
// ROUTES D'AUTHENTIFICATION
// ===================================================================

// Connexion Google
app.post('/api/auth/google', [
  body('googleToken').notEmpty().withMessage('Token Google requis'),
  body('googleToken').isLength({ min: 100 }).withMessage('Token Google invalide')
], async (req, res) => {
  try {
    console.log('üîê Tentative de connexion Google');
    console.log('üåê Origin de la requ√™te:', req.get('Origin'));
    
    // Validation des entr√©es
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      console.log('‚ùå Validation √©chou√©e:', errors.array());
      return res.status(400).json({ 
        error: 'Donn√©es invalides', 
        details: errors.array() 
      });
    }

    const { googleToken } = req.body;
    console.log('üé´ Token Google re√ßu (longueur):', googleToken.length);
    
    const result = await authService.authenticateWithGoogle(googleToken);
    
    console.log('‚úÖ Connexion Google r√©ussie pour:', result.user.email);
    
    res.json({
      success: true,
      token: result.jwtToken,
      user: result.user
    });
  } catch (error) {
    console.error('‚ùå Erreur authentification:', error.message);
    res.status(401).json({ 
      error: 'Authentification √©chou√©e',
      message: 'Token Google invalide ou expir√©',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// V√©rification du token JWT
app.get('/api/auth/verify', authService.verifyToken, (req, res) => {
  console.log('‚úÖ Token JWT v√©rifi√© pour:', req.user.email);
  res.json({
    valid: true,
    user: req.user
  });
});

// D√©connexion
app.post('/api/auth/logout', authService.verifyToken, (req, res) => {
  console.log('üö™ D√©connexion utilisateur:', req.user.email);
  res.json({ success: true, message: 'D√©connect√© avec succ√®s' });
});

// ===================================================================
// ROUTES D'ABONNEMENT S√âCURIS√âES
// ===================================================================

// V√©rifier l'abonnement actuel
app.get('/api/subscription/verify', authService.verifyToken, async (req, res) => {
  try {
    console.log('üîç V√©rification abonnement pour:', req.user.email);
    const subscription = await subscriptionService.verifyUserSubscription(req.user.id);
    res.json(subscription);
  } catch (error) {
    console.error('‚ùå Erreur v√©rification abonnement:', error);
    res.status(500).json({ error: 'Erreur serveur lors de la v√©rification' });
  }
});

// V√©rifier l'acc√®s √† une fonctionnalit√©
app.post('/api/subscription/check-access', [
  authService.verifyToken,
  body('feature').notEmpty().withMessage('Feature requis')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        error: 'Donn√©es invalides', 
        details: errors.array() 
      });
    }

    const { feature } = req.body;
    console.log(`üîë V√©rification acc√®s feature "${feature}" pour:`, req.user.email);
    
    const access = await subscriptionService.checkFeatureAccess(req.user.id, feature);
    res.json(access);
  } catch (error) {
    console.error('‚ùå Erreur v√©rification acc√®s:', error);
    res.status(500).json({ error: 'Erreur serveur' });
  }
});

// ===================================================================
// ROUTES DE PAIEMENT STRIPE (S√âCURIS√âES)
// ===================================================================

// Cr√©er une session de checkout
app.post('/api/payments/create-checkout-session', [
  authService.verifyToken,
  body('planId').notEmpty().withMessage('Plan ID requis'),
  body('priceId').notEmpty().withMessage('Price ID requis')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        error: 'Donn√©es invalides', 
        details: errors.array() 
      });
    }

    const { planId, priceId } = req.body;
    console.log(`üí≥ Cr√©ation session Stripe pour ${req.user.email}, plan: ${planId}`);

    const sessionId = await subscriptionService.createCheckoutSession({
      userId: req.user.id,
      userEmail: req.user.email,
      planId,
      priceId,
      successUrl: `${process.env.FRONTEND_URL}/payment-success`,
      cancelUrl: `${process.env.FRONTEND_URL}/subscription`
    });

    console.log('‚úÖ Session Stripe cr√©√©e:', sessionId);
    res.json({ sessionId });
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation session:', error);
    res.status(500).json({ error: 'Impossible de cr√©er la session de paiement' });
  }
});

// V√©rifier un paiement
app.get('/api/payments/verify-payment', authService.verifyToken, async (req, res) => {
  try {
    const { sessionId } = req.query;
    console.log(`üí∞ V√©rification paiement session: ${sessionId}`);
    
    if (!sessionId) {
      return res.status(400).json({ error: 'Session ID requis' });
    }

    const result = await subscriptionService.verifyPayment(sessionId, req.user.id);
    console.log('‚úÖ Paiement v√©rifi√©:', result.status);
    res.json(result);
  } catch (error) {
    console.error('‚ùå Erreur v√©rification paiement:', error);
    res.status(500).json({ error: 'Erreur lors de la v√©rification du paiement' });
  }
});

// ===================================================================
// ROUTES AUDIO S√âCURIS√âES
// ===================================================================

// Rechercher des audios
app.post('/api/audio/search', [
  authService.verifyToken,
  body('languageCode').optional().isLength({ min: 2, max: 3 }),
  body('category').optional().isLength({ min: 1, max: 50 }),
  body('word').optional().isLength({ min: 1, max: 100 })
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        error: 'Param√®tres de recherche invalides', 
        details: errors.array() 
      });
    }

    const { languageCode, category, word } = req.body;
    console.log(`üéµ Recherche audio: ${languageCode}/${category}/${word || 'all'}`);
    
    const results = await audioService.searchAudio({ languageCode, category, word });
    
    console.log(`‚úÖ Trouv√© ${results.length} audios`);
    res.json({ results });
  } catch (error) {
    console.error('‚ùå Erreur recherche audio:', error);
    res.status(500).json({ error: 'Erreur lors de la recherche audio' });
  }
});

// Statistiques audio
app.get('/api/audio/stats', authService.verifyToken, async (req, res) => {
  try {
    console.log('üìä R√©cup√©ration statistiques audio');
    const stats = await audioService.getAudioStats();
    res.json(stats);
  } catch (error) {
    console.error('‚ùå Erreur statistiques audio:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des statistiques' });
  }
});

// ===================================================================
// ROUTES DE PROGRESSION UTILISATEUR
// ===================================================================

// Sauvegarder la progression
app.post('/api/progress/save', [
  authService.verifyToken,
  body('languageCode').notEmpty().withMessage('Code langue requis'),
  body('progressData').isObject().withMessage('Donn√©es de progression requises')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        error: 'Donn√©es de progression invalides', 
        details: errors.array() 
      });
    }

    const { languageCode, progressData, totalXP, completedCategories } = req.body;
    console.log(`üíæ Sauvegarde progression ${languageCode} pour:`, req.user.email);
    
    const result = await subscriptionService.saveUserProgress({
      userId: req.user.id,
      languageCode,
      progressData,
      totalXP: totalXP || 0,
      completedCategories: completedCategories || []
    });

    console.log('‚úÖ Progression sauvegard√©e');
    res.json({ 
      success: true, 
      saved: true,
      timestamp: Date.now()
    });
  } catch (error) {
    console.error('‚ùå Erreur sauvegarde progression:', error);
    res.status(500).json({ error: 'Erreur lors de la sauvegarde' });
  }
});

// Charger la progression
app.get('/api/progress/:languageCode', authService.verifyToken, async (req, res) => {
  try {
    const { languageCode } = req.params;
    
    if (!languageCode || languageCode.length < 2) {
      return res.status(400).json({ error: 'Code langue invalide' });
    }

    console.log(`üìÇ Chargement progression ${languageCode} pour:`, req.user.email);
    const progress = await subscriptionService.getUserProgress(req.user.id, languageCode);
    res.json(progress || null);
  } catch (error) {
    console.error('‚ùå Erreur chargement progression:', error);
    res.status(500).json({ error: 'Erreur lors du chargement' });
  }
});

// ===================================================================
// ROUTE DE TEST POUR DEBUG CORS
// ===================================================================

// Route de test simple pour debug CORS
app.get('/api/test', (req, res) => {
  console.log('üß™ Route de test appel√©e');
  console.log('üåê Origin:', req.get('Origin'));
  console.log('üîç Headers:', req.headers);
  
  res.json({
    message: 'Test CORS r√©ussi !',
    origin: req.get('Origin'),
    timestamp: new Date().toISOString(),
    headers: req.headers
  });
});

// ===================================================================
// WEBHOOKS STRIPE (sans authentification)
// ===================================================================

// Webhook Stripe (endpoint raw pour signature)
app.post('/api/stripe/webhook', express.raw({type: 'application/json'}), async (req, res) => {
  const sig = req.headers['stripe-signature'];
  
  try {
    console.log('ü™ù Webhook Stripe re√ßu');
    
    // V√©rification signature Stripe
    let event;
    try {
      event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET);
    } catch (err) {
      console.error('‚ùå Signature webhook invalide:', err.message);
      return res.status(400).send(`Webhook signature error: ${err.message}`);
    }

    // Traiter l'√©v√©nement
    switch (event.type) {
      case 'checkout.session.completed':
        console.log('üí≥ Paiement compl√©t√©:', event.data.object.id);
        // Traiter le paiement
        break;
      case 'customer.subscription.updated':
        console.log('üîÑ Abonnement mis √† jour:', event.data.object.id);
        await subscriptionService.handleSubscriptionUpdate(event.data.object);
        break;
      case 'customer.subscription.deleted':
        console.log('‚ùå Abonnement annul√©:', event.data.object.id);
        await subscriptionService.handleSubscriptionCancellation(event.data.object);
        break;
      default:
        console.log(`‚ö†Ô∏è √âv√©nement webhook non g√©r√©: ${event.type}`);
    }

    res.json({received: true});
  } catch (error) {
    console.error('‚ùå Erreur webhook:', error);
    res.status(500).json({error: 'Erreur traitement webhook'});
  }
});

// ===================================================================
// ROUTES 404 ET GESTION D'ERREURS
// ===================================================================

// 404 Handler
app.use((req, res) => {
  console.log(`‚ùì Route non trouv√©e: ${req.method} ${req.path} depuis ${req.get('Origin')}`);
  res.status(404).json({ 
    error: 'Route non trouv√©e',
    path: req.path,
    method: req.method,
    timestamp: new Date().toISOString(),
    availableRoutes: [
      'GET /api/health',
      'GET /api/status', 
      'POST /api/auth/google',
      'GET /api/auth/verify',
      'GET /api/test'
    ]
  });
});

// Error Handler Global
app.use((error, req, res, next) => {
  console.error('üí• Erreur serveur:', error.message);
  console.error('üìç Stack:', error.stack);
  
  // CORS errors
  if (error.message.includes('CORS')) {
    console.error('üö´ Erreur CORS d√©tect√©e pour origin:', req.get('Origin'));
    return res.status(403).json({
      error: 'Acc√®s CORS refus√©',
      message: 'Origine non autoris√©e',
      origin: req.get('Origin'),
      allowedOrigins: allowedOrigins
    });
  }
  
  // Ne pas exposer les d√©tails d'erreur en production
  const isDevelopment = process.env.NODE_ENV !== 'production';
  
  res.status(error.status || 500).json({
    error: 'Erreur interne du serveur',
    message: isDevelopment ? error.message : 'Une erreur est survenue',
    timestamp: new Date().toISOString(),
    ...(isDevelopment && { stack: error.stack })
  });
});

// ===================================================================
// D√âMARRAGE DU SERVEUR
// ===================================================================

const server = app.listen(PORT, () => {
  console.log('\nüöÄ ===================================');
  console.log('üéµ JogoLinga Backend d√©marr√© !');
  console.log('üöÄ ===================================');
  console.log(`üì° Port: ${PORT}`);
  console.log(`üîó API: http://localhost:${PORT}/api/health`);
  console.log(`üåç Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`‚ö° Stripe: ${process.env.STRIPE_SECRET_KEY ? '‚úÖ Configur√©' : '‚ùå Manquant'}`);
  console.log(`üóÑÔ∏è  Supabase: ${process.env.SUPABASE_URL ? '‚úÖ Configur√©' : '‚ùå Manquant'}`);
  console.log(`üîë JWT: ${process.env.JWT_SECRET ? '‚úÖ Configur√©' : '‚ùå Manquant'}`);
  console.log(`üîê Google: ${process.env.GOOGLE_CLIENT_ID ? '‚úÖ Configur√©' : '‚ùå Manquant'}`);
  console.log(`üåê CORS Origins:`, allowedOrigins);
  console.log(`üéØ Frontend URL: ${process.env.FRONTEND_URL || 'Non d√©fini'}`);
  console.log('=====================================\n');
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('üõë Arr√™t du serveur...');
  server.close(() => {
    console.log('‚úÖ Serveur arr√™t√© proprement');
    process.exit(0);
  });
});

// Gestion des erreurs non captur√©es
process.on('uncaughtException', (error) => {
  console.error('üí• Uncaught Exception:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('üí• Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

module.exports = app;
